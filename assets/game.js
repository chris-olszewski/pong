/* Generated by Opal 0.7.0.dev */
Opal.modules["object"] = function($opal) {
  $opal.dynamic_require_severity = "error";
  var self = $opal.top, $scope = $opal, nil = $opal.nil, $breaker = $opal.breaker, $slice = $opal.slice, $klass = $opal.klass, $hash2 = $opal.hash2;

  $opal.add_stubs(['$attr_accessor', '$fetch', '$[]']);
  return (function($base, $super) {
    function $Object(){};
    var self = $Object = $klass($base, $super, 'Object', $Object);

    var def = self._proto, $scope = self._scope;

    self.$attr_accessor("position");

    return ($opal.defn(self, '$initialize', function(args) {
      var self = this;

      if (args == null) {
        args = $hash2([], {})
      }
      return self.position = args.$fetch("position", $scope.get('V')['$[]'](0, 0));
    }), nil) && 'initialize';
  })(self, null)
};

/* Generated by Opal 0.7.0.dev */
Opal.modules["ball"] = function($opal) {
  $opal.dynamic_require_severity = "error";
  var self = $opal.top, $scope = $opal, nil = $opal.nil, $breaker = $opal.breaker, $slice = $opal.slice, $klass = $opal.klass;

  $opal.add_stubs(['$attr_accessor', '$[]', '$/', '$x', '$move', '$bounce', '$display', '$collide', '$+', '$*', '$score', '$<', '$y', '$>', '$size', '$y=', '$min', '$max', '$reset_score', '$x=', '$each', '$respond_to?', '$==', '$class', '$touching?', '$-', '$height', '$score=', '$objects', '$fill_color=', '$push', '$translate', '$-@', '$fill_ellipse', '$pop']);
  return (function($base, $super) {
    function $Ball(){};
    var self = $Ball = $klass($base, $super, 'Ball', $Ball);

    var def = self._proto, $scope = self._scope, TMP_1;

    def.size = def.position = def.direction = def.radius = nil;
    self.$attr_accessor("radius");

    $opal.cdecl($scope, 'COLOR', $scope.get('C')['$[]']("#FFFFFF"));

    $opal.cdecl($scope, 'START_SPEED', 60);

    def.$initialize = TMP_1 = function(args) {var $zuper = $slice.call(arguments, 0);
      var self = this, $iter = TMP_1._p, $yield = $iter || nil;

      TMP_1._p = null;
      $opal.find_super_dispatcher(self, 'initialize', TMP_1, $iter).apply(self, $zuper);
      self.size = $scope.get('V')['$[]'](20, 20);
      self.radius = self.size.$x()['$/'](2);
      return self.direction = $scope.get('V')['$[]'](3, 1);
    };

    def.$update = function(elapsed, game) {
      var self = this;

      self.$move(elapsed, game);
      self.$bounce(game.$display(), game);
      return self.$collide(game);
    };

    def.$move = function(elapsed, game) {
      var self = this;

      return self.position = self.position['$+'](self.direction['$*'](($scope.get('START_SPEED')['$+'](game.$score()['$*'](10))))['$*'](elapsed));
    };

    def.$bounce = function(display, game) {
      var $a, $b, self = this;

      if ((($a = ((($b = self.position.$y()['$<'](self.radius)) !== false && $b !== nil) ? $b : self.position.$y()['$+'](self.radius)['$>'](display.$size().$y()))) !== nil && (!$a._isBoolean || $a == true))) {
        ($a = self.direction, $a['$y=']($a.$y()['$*'](-1)));
        self.position['$y=']([[self.position.$y(), self.radius].$max(), display.$size().$y()].$min());
        game.$reset_score();};
      if ((($a = ((($b = self.position.$x()['$<'](self.radius)) !== false && $b !== nil) ? $b : self.position.$x()['$+'](self.radius)['$>'](display.$size().$x()))) !== nil && (!$a._isBoolean || $a == true))) {
        ($a = self.direction, $a['$x=']($a.$x()['$*'](-1)));
        return self.position['$x=']([[self.position.$x(), self.radius].$max(), display.$size().$x()].$min());
        } else {
        return nil
      };
    };

    def.$collide = function(game) {
      var $a, $b, TMP_2, self = this;

      return ($a = ($b = game.$objects()).$each, $a._p = (TMP_2 = function(obj){var self = TMP_2._s || this, $a, $b, $c;
        if (self.position == null) self.position = nil;
        if (self.size == null) self.size = nil;
        if (self.radius == null) self.radius = nil;
        if (self.direction == null) self.direction = nil;
if (obj == null) obj = nil;
      if ((($a = ($b = ($c = obj['$respond_to?']("touching?"), $c !== false && $c !== nil ?obj.$class()['$==']($scope.get('Paddle')) : $c), $b !== false && $b !== nil ?obj['$touching?'](self.position, self.size) : $b)) !== nil && (!$a._isBoolean || $a == true))) {
          self.position['$y=']([[self.position.$y(), self.radius['$+'](16)].$max(), game.$display().$height()['$-'](16)['$-'](self.radius)].$min());
          ($a = game, $a['$score=']($a.$score()['$+'](1)));
          return ($a = self.direction, $a['$y=']($a.$y()['$*'](-1)));
          } else {
          return nil
        }}, TMP_2._s = self, TMP_2), $a).call($b);
    };

    return (def.$draw = function(d) {
      var self = this;

      d['$fill_color=']($scope.get('COLOR'));
      d.$push();
      d.$translate(self.position);
      d.$translate(self.size['$-@']()['$/'](2));
      d.$fill_ellipse(self.size['$/'](2), self.size['$/'](2));
      return d.$pop();
    }, nil) && 'draw';
  })(self, $scope.get('Object'))
};

/* Generated by Opal 0.7.0.dev */
Opal.modules["paddle"] = function($opal) {
  $opal.dynamic_require_severity = "error";
  var self = $opal.top, $scope = $opal, nil = $opal.nil, $breaker = $opal.breaker, $slice = $opal.slice, $klass = $opal.klass, $range = $opal.range;

  $opal.add_stubs(['$[]', '$fetch', '$-', '$/', '$+', '$to_a', '$to_i', '$x', '$first', '$last', '$y', '$!', '$empty?', '$&', '$move', '$==', '$position', '$mouse', '$x=', '$ball', '$min', '$max', '$width', '$display', '$fill_color=', '$push', '$translate', '$-@', '$begin_shape', '$move_to', '$line_to', '$end_shape', '$fill_shape', '$pop']);
  return (function($base, $super) {
    function $Paddle(){};
    var self = $Paddle = $klass($base, $super, 'Paddle', $Paddle);

    var def = self._proto, $scope = self._scope, TMP_1;

    def.position = def.size = def.controls = nil;
    $opal.cdecl($scope, 'COLOR', $scope.get('C')['$[]']("#FFFFFF"));

    $opal.cdecl($scope, 'MOVE_SPEED', 5);

    $opal.cdecl($scope, 'MAX_SPEED', 20);

    def.$initialize = TMP_1 = function(args) {var $zuper = $slice.call(arguments, 0);
      var self = this, $iter = TMP_1._p, $yield = $iter || nil;

      TMP_1._p = null;
      $opal.find_super_dispatcher(self, 'initialize', TMP_1, $iter).apply(self, $zuper);
      self.size = $scope.get('V')['$[]'](128, 16);
      self.controls = args.$fetch("controls", "ai");
      return self.velocity = $scope.get('V')['$[]'](0, 0);
    };

    def['$touching?'] = function(position, size) {
      var $a, self = this, obj_box = nil, obj_x = nil, obj_y = nil, my_box = nil, my_x = nil, my_y = nil;

      obj_box = [position['$-'](size['$/'](2)), position['$+'](size['$/'](2))];
      obj_x = ($range(obj_box.$first().$x().$to_i(), obj_box.$last().$x().$to_i(), false)).$to_a();
      obj_y = ($range(obj_box.$first().$y().$to_i(), obj_box.$last().$y().$to_i(), false)).$to_a();
      my_box = [self.position['$-'](self.size['$/'](2)), self.position['$+'](self.size['$/'](2))];
      my_x = ($range(my_box.$first().$x().$to_i(), my_box.$last().$x().$to_i(), false)).$to_a();
      my_y = ($range(my_box.$first().$y().$to_i(), my_box.$last().$y().$to_i(), false)).$to_a();
      return ($a = (obj_x['$&'](my_x))['$empty?']()['$!'](), $a !== false && $a !== nil ?(obj_y['$&'](my_y))['$empty?']()['$!']() : $a);
    };

    def.$update = function(elapsed, game) {
      var self = this;

      return self.$move(elapsed, game);
    };

    def.$move = function(elapsed, game) {
      var $a, self = this;

      if (self.controls['$==']("mouse")) {
        if ((($a = game.$mouse().$position()) !== nil && (!$a._isBoolean || $a == true))) {
          self.position['$x='](game.$mouse().$position().$x())}
        } else {
        self.position['$x='](game.$ball().$position().$x())
      };
      return self.position['$x=']([[self.position.$x(), (0)['$+'](self.size.$x()['$/'](2))].$max(), game.$display().$width()['$-'](self.size.$x()['$/'](2))].$min());
    };

    return (def.$draw = function(d) {
      var self = this;

      d['$fill_color=']($scope.get('COLOR'));
      d.$push();
      d.$translate(self.position);
      d.$translate(self.size['$-@']()['$/'](2));
      d.$begin_shape();
      d.$move_to($scope.get('V')['$[]'](0, 0));
      d.$line_to($scope.get('V')['$[]'](self.size.$x(), 0));
      d.$line_to($scope.get('V')['$[]'](self.size.$x(), self.size.$y()));
      d.$line_to($scope.get('V')['$[]'](0, self.size.$y()));
      d.$line_to($scope.get('V')['$[]'](0, 0));
      d.$end_shape();
      d.$fill_shape();
      return d.$pop();
    }, nil) && 'draw';
  })(self, $scope.get('Object'))
};

/* Generated by Opal 0.7.0.dev */
(function($opal) {
  $opal.dynamic_require_severity = "error";
  var self = $opal.top, $scope = $opal, nil = $opal.nil, $breaker = $opal.breaker, $slice = $opal.slice, $klass = $opal.klass, $hash2 = $opal.hash2;

  $opal.add_stubs(['$require', '$attr_accessor', '$[]', '$[]=', '$config', '$<<', '$new', '$/', '$size', '$display', '$width', '$-', '$height', '$fill_color=', '$first', '$select', '$==', '$class', '$stroke_color=', '$stroke_width=', '$font_size=', '$fill_text', '$clear', '$each', '$update', '$draw', '$compact', '$draw_score']);
  self.$require("object");
  self.$require("ball");
  self.$require("paddle");
  return (function($base, $super) {
    function $Pong(){};
    var self = $Pong = $klass($base, $super, 'Pong', $Pong);

    var def = self._proto, $scope = self._scope;

    def.objects = def.score = nil;
    self.$attr_accessor("input", "objects", "score");

    $opal.cdecl($scope, 'BG_COLOR', $scope.get('C')['$[]']("#000000"));

    $opal.cdecl($scope, 'COLOR', $scope.get('C')['$[]']("#FFFFFF"));

    self.$config()['$[]']("display")['$[]=']("size", $scope.get('V')['$[]'](600, 800));

    def.$setup = function() {
      var self = this;

      self.objects = [];
      self.objects['$<<']($scope.get('Ball').$new($hash2(["position"], {"position": self.$display().$size()['$/'](2)})));
      self.objects['$<<']($scope.get('Paddle').$new($hash2(["position", "controls"], {"position": $scope.get('V')['$[]'](self.$display().$width()['$/'](2), self.$display().$height()['$-'](8)), "controls": "mouse"})));
      self.objects['$<<']($scope.get('Paddle').$new($hash2(["position"], {"position": $scope.get('V')['$[]'](self.$display().$width()['$/'](2), 8)})));
      self.input = $hash2([], {});
      self.score = 0;
      return self.$display()['$fill_color=']($scope.get('BG_COLOR'));
    };

    def.$ball = function() {
      var $a, $b, TMP_1, self = this;

      return ($a = ($b = self.objects).$select, $a._p = (TMP_1 = function(obj){var self = TMP_1._s || this;
if (obj == null) obj = nil;
      return obj.$class()['$==']($scope.get('Ball'))}, TMP_1._s = self, TMP_1), $a).call($b).$first();
    };

    def.$reset_score = function() {
      var self = this;

      return self.score = 0;
    };

    def.$draw_score = function() {
      var self = this;

      self.$display()['$fill_color=']($scope.get('COLOR'));
      self.$display()['$stroke_color=']($scope.get('COLOR'));
      self.$display()['$stroke_width='](5);
      self.$display()['$font_size='](60);
      return self.$display().$fill_text(self.score, self.$display().$size()['$/'](2));
    };

    return (def.$update = function(elapsed) {
      var $a, $b, TMP_2, self = this;

      self.$display()['$fill_color=']($scope.get('BG_COLOR'));
      self.$display().$clear();
      ($a = ($b = self.objects.$compact()).$each, $a._p = (TMP_2 = function(o){var self = TMP_2._s || this;
if (o == null) o = nil;
      o.$update(elapsed, self);
        return o.$draw(self.$display());}, TMP_2._s = self, TMP_2), $a).call($b);
      return self.$draw_score();
    }, nil) && 'update';
  })(self, $scope.get('Game'));
})(Opal);

//# sourceMappingURL=game.map
;
